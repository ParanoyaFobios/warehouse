
┌─────────────┐            ┌──────────────────┐       ┌──────────────┐
│Пользователь │───────▶  │Действия с продукцией │───▶│    Сканер    │
└─────────────┘            └──────────────────┘       └──────────────┘
      │                          │  ▲
      ▼                          ▼  │
┌─────────────┐       ┌──────────────────┐       ┌──────────────┐
│   Отчёты    │◀─────│ Каталог продукции │◀─────┤ Инвентаризация│
└─────────────┘       └──────────────────┘       └──────────────┘
                              ▲
                              │
                      ┌──────────────┐
                      │ Количество   │
                      │ продукции    │
                      └──────────────┘
## Техническое задание (ТЗ) на разработку CRM‑системы складского учёта для текстильной компании Сonstancy

---

### 1. Цель проекта

Разработать веб‑CRM с модулем складского учета, которая автоматизирует:

- приход и расход товаров (штучно и упаковками/баулами);
- учет расходных материалов и их списание на изделия;
- быструю работу со штрихкодами для всех складских операций;
- распределение прав доступа сотрудников;
- кроссплатформенную работу (ПК, планшет, смартфон).

---

## 2. Функциональные требования

### 2.1. Управление товарами

- Создание карточек товара с полями:
    - Артикул, Наименование, Категория, Фото;
    - Единицы измерения (штуки, метры, килограмы);
    - Штрихкод;
    - Тип упаковки (штучный, баул, коробка);
    - Количество внутри упаковки (для баулов).
- Приход товара:
    - Ввод вручную или сканированием штрихкода;
    - Возможность прихода в баулах (указывается количество единиц внутри упаковки);
    - При сканировании баула — система автоматически добавляет указанное количество единиц на склад.
- Расход товара:
    - Списание поштучно или целой упаковкой;
    - При сканировании баула — система вычитает из остатков количество, указанное для данной упаковки.

---

### 2.2. Учёт расходных материалов

- Ведение базы материалов (ткани, фурнитура, наполнитель);
- Приход материалов (аналогично товарам);
- Списание материалов на изделия или производственные нужды.

---

### 2.3. Складские операции

- Инвентаризация: сверка фактических остатков (штучных и упакованных);
- Резервирование товаров под заказы;
- Перемещение между складами с фиксацией истории.

---

## 3. Логика работы со штрихкодами

### 3.1. Приход товара

- Сканирование штрихкода товара → автоматическое добавление одной единицы.
- Сканирование штрихкода баула → автоматическое добавление количества, указанного для данной упаковки.
- Возможность ручного ввода данных (если нет сканера).
- Сканирование с помощью телефона (камеры)

### 3.2. Списание товара (расход)

- Сканированием штрихкода:
    - Для единичного товара — списывается 1 единица.
    - Для баула — списывается количество, указанное для этой упаковки.
    - В журнале фиксируются: ID штрихкода, количество, пользователь, дата/время.
- Ручным вводом:
    - Выбор товара из списка;
    - Ввод количества для списания;
    - Списание проводится вручную, операция логируется с отметкой «ручное списание».

---

## 4. Штрихкодирование и упаковка (баулы)

- Поддержка USB и Bluetooth сканеров.
- Возможность генерации и печати штрихкодов как для штучных товаров, так и для упаковок.
- При упаковке товаров в баул:
    - Оператор указывает количество единиц внутри;
    - Система генерирует отдельный штрихкод для упаковки;
    - При сканировании баула учитывается сразу все количество, без сканирования каждой единицы.

---

## 5. Пользователи и уровни доступа

- Администратор – полный доступ, управление пользователями, настройка ролей.
- Менеджер склада – приход/расход, упаковка, инвентаризация.
- Сотрудник – только разрешенные операции (например, сканирование и приход).
- Бухгалтер – доступ к отчетам, финансовым документам.

---

## 6. Отчеты и аналитика

- Отчет по остаткам (с разделением штучных и упакованных остатков);
- Движение товаров и материалов за период;
- Списание материалов по изделиям;
- Журнал операций (кто, что, когда сделал);
- Экспорт отчетов в Excel, CSV, PDF.

---

## 7. Интерфейс и UX

- Адаптивный дизайн (работает на ПК, планшетах, смартфонах);
- Кроссбраузерность (Chrome, Firefox, Safari, Edge);
- Поиск по артикулу, штрихкоду, названию;
- Минимум действий для типичных операций (оптимизированный UX).

---

## 8. Технические требования

- Backend: Laravel (PHP) или Node.js (NestJS) — REST API.
- Frontend: Vue.js / React — SPA с адаптивной версткой.
- База данных: MySQL / PostgreSQL.

---

## 9. Безопасность

- HTTPS;
- Авторизация (логин/пароль)
- Логирование всех действий пользователей;
- Разграничение прав доступа.

---
## 10. Дополнительные возможности

- Печать этикеток для упаковок;
- Возможность сканирования штрихкодов камерой смартфона (PWA);



## 11. Этапы разработки

1. Аналитика, проектирование процессов, макеты интерфейсов;
2. Разработка MVP (приход/расход, учет упаковок, сканеры);
3. Внедрение ролей, отчетов, журналов операций;
4. Тестирование и запуск;

---

## 12. Особенности учета упаковок

- У каждой упаковки (баула) есть свой штрихкод;
- Система хранит данные о количестве единиц внутри;
- Сканирование баула при приходе/расходе автоматически изменяет остаток на указанное количество.



Структура приложений Django
1. core (базовые настройки и утилиты)
Настройки проекта

Кастомные мидлвары

Утилитные функции

2. users (пользователи и auth)
python
# models.py
from django.contrib.auth.models import AbstractUser

class User(AbstractUser):
    phone = models.CharField(max_length=20, blank=True)
    warehouse = models.ForeignKey('warehouses.Warehouse', null=True, blank=True, on_delete=models.SET_NULL)
    
    # Используем стандартные группы Django вместо кастомных ролей
3. products (товары и материалы)
python
# models.py
class ProductType(models.Model):
    """Тип продукта: товар или материал"""
    name = models.CharField(max_length=100)  # "Ткань", "Фурнитура", "Готовая продукция"
    is_material = models.BooleanField(default=False)

class Unit(models.Model):
    """Единицы измерения"""
    name = models.CharField(max_length=20)  # "рулон", "метр", "штука"
    code = models.CharField(max_length=10)  # "roll", "m", "pcs"

class Product(models.Model):
    name = models.CharField(max_length=255)
    article = models.CharField(max_length=50, unique=True)
    type = models.ForeignKey(ProductType, on_delete=models.PROTECT)
    unit = models.ForeignKey(Unit, on_delete=models.PROTECT)
    barcode = models.CharField(max_length=50, unique=True, blank=True)
    photo = models.ImageField(upload_to='products/', blank=True)
    items_per_package = models.PositiveIntegerField(
        default=1,
        help_text="Сколько единиц содержится в упаковке (для баулов/коробок)"
    )
    is_packaged = models.BooleanField(
        default=False,
        help_text="Учитывается ли товар упаковками (баулами/коробками)"
    )

class Package(models.Model):
    """Упаковки (баулы/коробки)"""
    barcode = models.CharField(max_length=50, unique=True)
    product = models.ForeignKey(Product, on_delete=models.PROTECT)
    quantity = models.PositiveIntegerField(
        help_text="Фактическое количество единиц в упаковке"
    )
    created_at = models.DateTimeField(auto_now_add=True)
4. warehouses (склады и запасы)
python
# models.py
class Warehouse(models.Model):
    name = models.CharField(max_length=100)
    address = models.TextField(blank=True)

class Stock(models.Model):
    product = models.ForeignKey('products.Product', on_delete=models.CASCADE)
    warehouse = models.ForeignKey('Warehouse', on_delete=models.CASCADE)
    quantity = models.DecimalField(max_digits=15, decimal_places=3, default=0)
    
    class Meta:
        unique_together = ('product', 'warehouse')
5. operations (движение товаров)
python
# models.py
class Operation(models.Model):
    OPERATION_TYPES = (
        ('income', 'Приход'),
        ('outcome', 'Расход'),
        ('transfer', 'Перемещение'),
    )
    
    operation_type = models.CharField(max_length=20, choices=OPERATION_TYPES)
    warehouse = models.ForeignKey('warehouses.Warehouse', on_delete=models.PROTECT)
    to_warehouse = models.ForeignKey('warehouses.Warehouse', null=True, blank=True, 
                                   related_name='incoming_transfers', on_delete=models.PROTECT)
    user = models.ForeignKey('users.User', on_delete=models.PROTECT)
    created_at = models.DateTimeField(auto_now_add=True)
    comment = models.TextField(blank=True)

class OperationItem(models.Model):
    operation = models.ForeignKey(Operation, on_delete=models.CASCADE, related_name='items')
    product = models.ForeignKey('products.Product', on_delete=models.PROTECT)
    package = models.ForeignKey('products.Package', null=True, blank=True, on_delete=models.SET_NULL)
    quantity = models.DecimalField(max_digits=15, decimal_places=3)
    is_manual = models.BooleanField(default=False)
Логика работы с упаковками
Для вашего вопроса о приемке баулов предлагаю такой подход:

Админка:

Создаем товар "Рулоны ткани X"

Указываем is_packaged=True и items_per_package=20

Процесс приемки:

python
# services/warehouse.py
def process_income(user, warehouse_id, product_id, quantity, is_package=False):
    product = Product.objects.get(id=product_id)
    
    if is_package:
        # Для упаковки автоматически умножаем количество
        actual_quantity = quantity * product.items_per_package
        
        # Создаем запись об упаковке
        package = Package.objects.create(
            barcode=generate_barcode(),
            product=product,
            quantity=actual_quantity
        )
    else:
        actual_quantity = quantity
        package = None
    
    # Создаем операцию
    operation = Operation.objects.create(
        operation_type='income',
        warehouse_id=warehouse_id,
        user=user
    )
    
    OperationItem.objects.create(
        operation=operation,
        product=product,
        package=package,
        quantity=actual_quantity
    )
    
    # Обновляем остатки
    stock, created = Stock.objects.get_or_create(
        product=product,
        warehouse_id=warehouse_id
    )
    stock.quantity += actual_quantity
    stock.save()
Интерфейс для складовщика
Вариант A (простой):

Выбирает товар из списка

Вводит количество упаковок (баулов)

Система автоматически рассчитывает общее количество

Вариант B (гибкий):

Выбирает товар

Выбирает тип ввода: "Поштучно" или "Упаковками"

В зависимости от выбора:

Поштучно: вводит количество единиц

Упаковками: вводит количество упаковок, система показывает "Итого: X упаковок = Y единиц"

API для мобильного сканера
python
# api/views.py
class ScanAPIView(APIView):
    def post(self, request):
        barcode = request.data.get('barcode')
        warehouse_id = request.data.get('warehouse_id')
        
        # Ищем товар или упаковку
        try:
            product = Product.objects.get(barcode=barcode)
            return Response({
                'type': 'product',
                'product_id': product.id,
                'name': product.name,
                'unit': product.unit.name,
                'is_packaged': product.is_packaged
            })
        except Product.DoesNotExist:
            try:
                package = Package.objects.get(barcode=barcode)
                return Response({
                    'type': 'package',
                    'package_id': package.id,
                    'product_id': package.product.id,
                    'quantity': package.quantity,
                    'product_name': package.product.name
                })
            except Package.DoesNotExist:
                return Response({'error': 'Штрихкод не найден'}, status=404)
Итоговая структура проекта
text
warehouse_project/
├── core/               # Базовые настройки
├── users/              # Пользователи
├── products/           # Товары и материалы
│   ├── models.py       # Product, Package, Unit
│   ├── admin.py        # Кастомизация админки
│   └── services.py     # Логика работы с товарами
├── warehouses/         # Склады и запасы
├── operations/         # Движение товаров
└── api/                # DRF endpoints
    └── v1/
        ├── auth.py     # Аутентификация
        ├── scan.py     # API для сканера
        └── warehouse.py # Операции со складом
Такая структура:

Использует стандартные механизмы Django (группы вместо кастомных ролей)

Разделяет логику по приложениям

Предлагает гибкую систему учета упаковок

Позволяет легко расширять функционал

Для резервирования можно будет добавить флаг is_reserved в модель Stock и отдельные методы для работы с резервами, когда такая потребность возникнет.